package uim;
package_type client;

const QMI_UIM_GET_CARD_STATUS = 0x2F;
const QMI_UIM_CHANGE_PROVISIONING_SESSION = 0x38;
const QMI_UIM_GET_SLOT_STATUS = 0x0047;
const QMI_UIM_SLOT_STATUS_IND = 0x0048;

const QMI_UIM_SESSION_TYPE_PRIMARY_GW_PROVISIONING = 0;

const QMI_UIM_CARD_STATE_ABSENT = 0;
const QMI_UIM_CARD_STATE_PRESENT = 1;
const QMI_UIM_CARD_STATE_ERROR = 2;

const QMI_UIM_PHYSICAL_CARD_STATE_UNKNOWN = 0;
const QMI_UIM_PHYSICAL_CARD_STATE_ABSENT  = 1;
const QMI_UIM_PHYSICAL_CARD_STATE_PRESENT = 2;

const QMI_UIM_CARD_APPLICATION_STATE_UNKNOWN                     = 0;
const QMI_UIM_CARD_APPLICATION_STATE_DETECTED                    = 1;
const QMI_UIM_CARD_APPLICATION_STATE_PIN1_OR_UPIN_PIN_REQUIRED   = 2;
const QMI_UIM_CARD_APPLICATION_STATE_PUK1_OR_UPIN_PUK_REQUIRED   = 3;
const QMI_UIM_CARD_APPLICATION_STATE_CHECK_PERSONALIZATION_STATE = 4;
const QMI_UIM_CARD_APPLICATION_STATE_PIN1_BLOCKED                = 5;
const QMI_UIM_CARD_APPLICATION_STATE_ILLEGAL                     = 6;
const QMI_UIM_CARD_APPLICATION_STATE_READY                       = 7;

struct card_status {
	u16 index_gw_primary;
	u16 index_1x_primary;
	u16 index_gw_secondary;
	u16 index_1x_secondary;
	u8 cards_n;
	struct {
		u8 card_state;
		u8 upin_state;
		u8 upin_retries;
		u8 upuk_retries;
		u8 error_code;
		u8 applications_n;
		struct {
			u8 type;
			u8 state;
			u8 personalization_state;
			u8 personalization_feature;
			u8 personalization_retries;
			u8 personalization_unblock_retries;
			u8 application_identifier_value_n;
			u8 *application_identifier_value;
			u8 upin_replaces_pin1;
			u8 pin1_state;
			u8 pin1_retries;
			u8 puk1_retries;
			u8 pin2_state;
			u8 pin2_retries;
			u8 puk2_retries;
		} *applications;
	} *cards;
};

struct provisioning_session_change {
	u8 session_type;
	u8 activate;
};

struct provisioning_session_application {
	u8 slot;
	u8 application_identifier_value_n;
	u8 *application_identifier_value;
};

struct physical_slot_state {
	u8 slots_n;
	struct {
		u32 card_state;
		u32 slot_state;
		u8 logical_slot;
		u8 iccid_n;
		u8 *iccid;
	} *slots;
};

struct physical_slot_info {
	u8 slots_n;
	struct {
		u32 card_protocol;
		u8 valid_applications;
		u8 atr_value_n;
		u8 *atr_value;
		u8 is_euicc;
	} *slots;
};

request get_card_status_req {
} = 0x002F;

response get_card_status_resp {
	required qmi_response_type_v01 result = 0x02;
	optional card_status status = 0x10;
} = 0x002F;

request change_provisioning_session_req {
	optional provisioning_session_change session_change = 0x01;
	optional provisioning_session_application application_information = 0x10;
} = 0x0038;

response change_provisioning_session_resp {
	required qmi_response_type_v01 result = 0x02;
} = 0x0038;

# https://gitlab.freedesktop.org/mobile-broadband/libqmi/-/blob/main/gobi-api/Gobi_2012-06-18-1054/GobiConnectionMgmt/GobiConnectionMgmtAPIStructs.h#L19609
request icc_open_logical_channel_req {
	required u8 slot = 0x1;
	optional u8 application_id(32) = 0x10; # 16 is the max length
	optional u8 fileControlInfo = 0x11;
} = 0x0042;

response icc_open_logical_channel_resp {
	required qmi_response_type_v01 result = 0x02;
	optional u8 channel_id = 0x10;
	# Actually two 8-bit values: mSW1 and mSW2
	optional u16 card_result = 0x11;
	optional u8 select_response(255) = 0x12;
} = 0x0042;

request get_slot_status_req {
} = 0x0047;

response get_slot_status_resp {
	required qmi_response_type_v01 result = 0x02;
	optional physical_slot_state slot_state = 0x10;
	optional physical_slot_info slot_info = 0x11;
	optional u8 eid_info[32] = 0x12;
} = 0x0047;

indication get_slot_status_ind {
	required physical_slot_state slot_state = 0x10;
	optional physical_slot_info slot_info = 0x11;
	optional u8 eid_info[32] = 0x12;
} = 0x0048;
