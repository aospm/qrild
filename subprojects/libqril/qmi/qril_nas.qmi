package nas;
package_type client;

const QMI_NAS_EVENT_REPORT = 0x02;
const QMI_NAS_REGISTER_INDICATIONS = 0x03;
const QMI_NAS_SERVING_SYSTEM_REPORT = 0x24;
const QMI_NAS_GET_OPERATOR_NAME = 0x39;
# https://gitlab.freedesktop.org/mobile-broadband/libqmi/-/blob/main/gobi-api/GobiAPI_2013-07-31-1347/Core/QMIEnum.h#L474
const QMI_NAS_SUBSCRIPTION_INFO_REPORT = 0x48;
const QMI_NAS_ERROR_RATE_REPORT = 0x53;
const QMI_NAS_RF_BAND_INFO_REPORT = 0x66;
const QMI_NAS_GET_LTE_CPY_CA_INFO = 0xAC;

# get_lte_cphy_ca_info_resp.dl_bandwidth
# in MHz
const QMI_NAS_DL_BANDWIDTH_1_4      = 0;
const QMI_NAS_DL_BANDWIDTH_3        = 1;
const QMI_NAS_DL_BANDWIDTH_5        = 2;
const QMI_NAS_DL_BANDWIDTH_10       = 3;
const QMI_NAS_DL_BANDWIDTH_15       = 4;
const QMI_NAS_DL_BANDWIDTH_20       = 5;
const QMI_NAS_DL_BANDWIDTH_INVALID  = 6;

const QMI_NAS_SIGNAL_STRENGTH_REQUEST_NONE       = 0;
const QMI_NAS_SIGNAL_STRENGTH_REQUEST_RSSI       = 1;
const QMI_NAS_SIGNAL_STRENGTH_REQUEST_ECIO       = 2;
const QMI_NAS_SIGNAL_STRENGTH_REQUEST_IO         = 4;
const QMI_NAS_SIGNAL_STRENGTH_REQUEST_SINR       = 8;
const QMI_NAS_SIGNAL_STRENGTH_REQUEST_ERROR_RATE = 16;
const QMI_NAS_SIGNAL_STRENGTH_REQUEST_RSRQ       = 32;
const QMI_NAS_SIGNAL_STRENGTH_REQUEST_LTE_SNR    = 64;
const QMI_NAS_SIGNAL_STRENGTH_REQUEST_LTE_RSRP   = 128;

const QMI_NAS_GET_SIGNAL_STRENGTH = 0x20;

# serving_system.registration_state
const QMI_NAS_REGISTRATION_STATE_NOT_REGISTERED           = 0x00;
const QMI_NAS_REGISTRATION_STATE_REGISTERED               = 0x01;
const QMI_NAS_REGISTRATION_STATE_NOT_REGISTERED_SEARCHING = 0x02;
const QMI_NAS_REGISTRATION_STATE_REGISTRATION_DENIED      = 0x03;
const QMI_NAS_REGISTRATION_STATE_UNKNOWN                  = 0x04;

# serving_system.XX_attach_state
const QMI_NAS_ATTACH_STATE_UNKNOWN  = 0x00;
const QMI_NAS_ATTACH_STATE_ATTACHED = 0x01;
const QMI_NAS_ATTACH_STATE_DETACHED = 0x02;

const QMI_NAS_RADIO_INTERFACE_UNKNOWN     = 0xFF;
const QMI_NAS_RADIO_INTERFACE_NONE        = 0x00;
const QMI_NAS_RADIO_INTERFACE_CDMA_1X     = 0x01;
const QMI_NAS_RADIO_INTERFACE_CDMA_1XEVDO = 0x02;
const QMI_NAS_RADIO_INTERFACE_AMPS        = 0x03;
const QMI_NAS_RADIO_INTERFACE_GSM         = 0x04;
const QMI_NAS_RADIO_INTERFACE_UMTS        = 0x05;
const QMI_NAS_RADIO_INTERFACE_LTE         = 0x08;
const QMI_NAS_RADIO_INTERFACE_TD_SCDMA    = 0x09;
const QMI_NAS_RADIO_INTERFACE_5GNR        = 0x0C;

# The strength for the requested interface ??
struct signal_strength {
	i8 strength;
	i8 interface;
};

struct ss_value {
	u8 val;
	i8 interface;
};

struct network_reject_info {
	u8 enable_network_reject_indications;
	u8 suppress_system_info_indications;
};

# LTE Cphy CA Info
struct lte_cphy_agg_scell {
	u16 pci; # Physical cell ID
	u16 rx_chan;
	u32 dl_bandwidth;
	u16 lte_band;
	u32 state;
};

struct serving_system {
	u8 registration_state;
	u8 cs_attach_state;
	u8 ps_attach_state;
	u8 selected_network;
	u8 radio_interfaces_n;
	u8 *radio_interfaces;
};

struct current_plmn {
	u16 mcc;
	u16 mnc;
	string description;
};

struct service_status {
	u8 status;
	u8 capability;
	u8 hdr_status;
	u8 hdr_hybrid;
	u8 forbidden;
};

request register_indications_req {
	required u8 system_selection_preference = 0x10;
	required u8 ddtm_events = 0x12;
	required u8 serving_system_events = 0x13;
	required u8 dual_standby_preference = 0x14;
	required u8 subscription_info = 0x15;
	required u8 network_time = 0x17;
	required u8 system_info = 0x18;
	required u8 signal_info = 0x19;
	required u8 error_rate = 0x1A;
	required u8 hdr_new_uati_assigned = 0x1B;
	required u8 hdr_session_closed = 0x1C;
	required u8 managed_roaming = 0x1D;
	required u8 current_plmn_name = 0x1E;
	required u8 embms_status = 0x1F;
	required u8 rf_band_information = 0x20;
	required network_reject_info network_reject_information = 0x21;
} = 0x03;

request get_signal_strength_req {
	required u16 mask = 0x10;
} = 0x20;

response get_signal_strength_resp {
	optional signal_strength strength = 0x01;
	required qmi_response_type_v01 res = 0x02;
	optional signal_strength strength_list(16) = 0x10;
	optional ss_value rssi_list(16) = 0x11;
	optional ss_value ecio_list(16) = 0x12;
	optional u32 io = 0x13;
	optional u8 sinr = 0x14;
	optional ss_value err_rate_list(16) = 0x15;
	optional ss_value rsrq = 0x16;
	optional i16 lte_snr = 0x17;
	optional i16 lte_rsrp = 0x18;
} = 0x0020;

indication serving_system_ind {
	optional serving_system system = 0x01;
	optional u8 data_service_cap = 0x11; # do we have data?
	optional current_plmn plmn = 0x12;
	optional service_status status = 0x22;
} = 0x0024;

request set_operating_mode_req {
	required u8 mode = 0x01;
} = 0x002E;

request set_operating_mode_resp {
	required qmi_response_type_v01 res = 0x02;
} = 0x002E;

struct service_provider_name {
	u8 display_condition;
	string name;
};

struct operator_plmn {
	char mcc[3];
	char mnc[3];
	u16 lac1;
	u16 lac2;
	u8 name_record_indicator;
};

struct operator_plmn_name {
	u8 name_encoding;
	u8 short_country_initials;
	u8 long_name_spare_bits;
	u8 short_name_spare_bits;
	u8 long_name_n;
	u8 *long_name;
	u8 short_name_n;
	u8 *short_name;
};

response get_operator_name_resp {
	required qmi_response_type_v01 res = 0x02;
	optional service_provider_name provider_name = 0x10;
	optional operator_plmn operator_plmn_list(64) = 0x11;
	optional operator_plmn_name operator_plmn_names(64) = 0x12;
	optional string operator_string_name = 0x13;
	optional operator_plmn_name nitz_info = 0x14;
} = 0x0039;

#indication get_operator_name_ind {
#	optional service_provider_name provider_name = 0x10;
#	optional operator_plmn operator_plmn_list(64) = 0x11;
#	optional operator_plmn_name operator_plmn_names(64) = 0x12;
#	optional string operator_string_name = 0x13;
#	optional operator_plmn_name nitz_info = 0x14;
#} = 0x003A;

struct geran_info {
	u8 x;
};

response get_cell_loc_info {
} = 0x0043;

response get_lte_cphy_ca_info_resp {
	required qmi_response_type_v01 res = 0x02;
	optional u32 dl_bandwidth = 0x11;
	optional lte_cphy_agg_scell phy_scell_info = 0x12;
	# FIXME: add the rest of the TLVs
} = 0x00AC;
